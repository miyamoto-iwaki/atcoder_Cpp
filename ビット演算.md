# ビット演算
## AND、OR、XOR演算
| x | y | x AND y | x OR y| x XOR y |
|:-----------:|:------------:|:------------:|:------------:|:------------:|
|0|0|0|0|0|
|0|1|0|1|1|
|1|0|0|1|1|
|1|1|1|1|0|
## 集合の操作とビット演算の対応の例
| 操作 | 対応するビット演算 | 
|:-----------|:------------|
| 2つの集合に共通している要素を取り出す       | AND演算   | 
| 2つの集合のうち少なくとも一方に存在する要素を取り出す	     | OR演算      | 
| ある集合に含まれない要素取り出す      | NOT演算      |

# STLのbitset
C++でビット列を扱うには`bitset`を使う。
```cpp
bitset<ビット数> bit;  // すべてのビットが0の状態で初期化される
bitset<ビット数> bit("ビット列(長さはビット数に合わせる)");  // 指定したビット列で初期化される
bitset<ビット数> bit(x); // 整数 x をビット列に変換
```
※ビット数は**定数**
以下、bit を`bitset`の変数とする。

## ビット演算子
| ビット演算 | `bitset`の演算子 | 使い方 | 
|:-----------|:------------|:------------|
| AND演算      | `&`   | `変数1 & 変数2` |
| OR演算	     |  `\|` | `変数1 \| 変数2` |
| XOR演算      |   `^` | `変数1 ^ 変数2` |
| NOT演算      |   `~` | `~変数` |
| 論理左シフト演算      |   `<<` | `変数 << シフトするビット数` |
| 論理右シフト演算      |   `>>` | `変数 >> シフトするビット数` |

※ビット演算に用いる演算子は優先度が低い。明示的に`()`でくくる必要がある。
`x & y > 0` -> `x & (y > 0)` と解釈される

## bitsetの操作
| 操作 | 書き方 | 備考 | 
|:-----------|:------------|:------------|
| 全てのビットを1にする    | `bit.set();`   |  |
|特定のビットを1にする     | `bit.set(位置);`   | 1にするビットの位置を0始まりのインデックスで指定する。 |
| 特定のビットの値を変更する     | `bit.set(位置, 値);`   | 変更するビットの位置を0始まりのインデックスで指定する。値は0か1を指定する。 |
| 全てのビットを0にする    | `bit.reset();`   |  |
| 特定のビットを0にする    | `bit.reset(位置);`   | 0にするビットの位置を0始まりのインデックスで指定する。 |
| 全てのビットを反転する  | `bit.flip();`   |  |
| 特定のビットを反転する  | `bit.flip(位置);`   | 反転するビットの位置を0始まりのインデックスで指定する。 |
| 特定のビットが1になっているかを調べる	     |  `bit.test(調べる位置);` | 調べるビットの位置を0始まりのインデックスで指定する。ビットが1なら`true`を、ビットが0なら`false`を返す。|
| 全てのビットが1になっているかを判定する	     |  `bit.all();` | すべてのビットが1なら`true`を、そうでなければ`false`を返す。|
| いずれかのビットが1になっているかを判定する	     |  `bit.any();` | 1のビットが存在するなら`true`を、そうでなければ`false`を返す。|
|1のビットの個数を数える|`bit.count()`||
|ビット列を出力する|`cout << bit`||
|ビット列を文字列化する|`bit.to_string()`||
|ビットに対するアクセス|`bit[位置]`|基本的には`test`、`set`/`reset`と同等ですが、範囲外の位置を指定した場合にエラーにならないことに注意する必要がある。|
|bitsetから整数への変換|`bit.to_ullong()`||

※位置の指定について、ビット列の右から左にかけて0, 1, 2, ...と対応する。 配列の位置の指定とは逆になっていることに注意せよ。

```cpp
bitset<4> S("0000");
S.set(0, 1);  // 0番目のビットを1にする -> 0001
bi.test(0) // -> true
bi.test(3) // -> false
```

## ビット全探索
ビット全探索によって、組合せの全列挙をシンプルに実装することができる。
以下、ビット全探索の雛形。
```cpp
for (int bit = 0; bit < (1<<n); ++bit) {
  for (int i = 0; i < n; ++i) {
      if (bit & (1<<i)) { // 初めのビットごとに1であるかを走査
          // 1であるときの操作を記述
      }
  }
}
```





